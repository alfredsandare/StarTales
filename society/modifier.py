# A modifier is a value in a civ. It can affect other values in the civ, and be affected by other values in the civ.

# Modifier is a modifier global for a civilization
class Modifier:
    def __init__(self, name, base_value, affects: list[list[str, float, bool]] = None, 
                 affected_by: list[str] = None, id: str = None, 
                 get_base_value_func: callable = None, is_base: bool = False,
                 affects_generators: list = None):

        self.name = name
        self.base_value = base_value

        # list of tuples of the form (affected_modifier, multiplier, is_percentage)
        # if is_percentage is True, the value will be multiplied by the multiplier
        # if is_percentage is False, the value will be multiplied by the multiplier before added to the affected modifer
        self.affects = affects if affects is not None else []

        # Add a fourth value to every tuple. It indicates whether or not the
        # tuple has been generated by affects_generators.
        self.affects = [tuple(affect) + (False,) for affect in self.affects]

        # List of tuples on the form (get_ids_func, multiplier, is_percentage)
        self.affects_generators = affects_generators \
            if affects_generators is not None else []

        self.affected_by = affected_by if affected_by is not None else []
        self.id = id
        self.get_base_value_func = get_base_value_func
        self.is_base = is_base

        self.added_value = 0
        self.added_percentage = 0  # this is a fraction, not an actual percentage
        self.value = 0

    def __str__(self):
        return f"Global Modifier - id: {self.id}, name: {self.name}, value: {self.value}"
    
    def __repr__(self):
        return f"{self.name}: {self.value}"

    def calculate_value(self):
        if self.get_base_value_func is not None:
            self.base_value = self.get_base_value_func()

        self.value = (self.base_value + self.added_value) * (1 + self.added_percentage)

        # Reset the added values for the next calculation
        self.added_value = 0
        self.added_percentage = 0

    def calculate_affects(self):
        self.affects = [affect for affect in self.affects if not affect[3]]
        for affect in self.affects_generators:
            ids = affect[0]()  # affect[0] is callable and returns list of strs
            for id_ in ids:
                self.affects.append((id_, affect[1], affect[2], True))

    def get_value(self):
        return self.value

    def get_affect_modifier_list_id(self, modifier_id):
        """ Returns the int id of given modifier in self.affects """
        for i, affect in enumerate(self.affects):
            if affect[0] == modifier_id:
                return i
        return None

# LocalModifier is a modifier that is local to a specific cb or species
class LocalModifier(Modifier):
    def __init__(self, name, base_value, place_type, place, 
                 affects: list[str] = None, affected_by: list[str] = None,
                 id=None, get_base_value_func: callable = None, 
                 is_base: bool = False):

        super().__init__(name, base_value, affects, affected_by, 
                         id, get_base_value_func, is_base)
        self.place_type = place_type  # 'cb' or 'species'
        self.place = place  # species id or cb id

    def __str__(self):
        return f"Local Modifier - id: {self.id}, name: {self.name}, value: {self.value}"
